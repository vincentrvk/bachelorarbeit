Bitte baue ein Skript für den Import von Kategorien von Akeneo zur SAP Commerce Cloud.

1. Header, Properties und Body
--------------------
Headers:
aknPIMClientSecret = 
X-PIM-URL = 
X-PIM-CLIENT-ID = 
Content-Type = application/json
AKN PIM Category code = 

Properties:
catId = 
catVersion = 
AKN GraphQl URL = 
akeneoUsername =
akeneoPassword = 
CommerceCloudURL
commerceUsername = 
commercePassword = 

Sollten Properties und Header bereits im Message-Objekt vorhanden sein, befülle die Variablen mit diesen Werten. Ist ein Wert nicht zu finden benutze "placeholder".

2. Request: "Call Akeneno-Authorize"
----------------------------------
Adresse: AKN GraphQl URL
Methode: POST
Authentifizierung: Basic-Authentication
Header: X-PIM-URL, X-PIM-CLIENT-ID
Body: {"query":"query getToken{ token(username: \"${header.akeneoUsername}\", password: \"${header.akeneoPassword}\", clientId: \"${header.X-PIM-CLIENT-ID}\", clientSecret: \"${header.aknPIMClientSecret}\") { data { accessToken } } }"}

Response Handling: 
- Setze den Header "X-PIM-TOKEN" mit dem JSON Wert: responseData.data.token.data.accessToken


3. Request: "Get Data"
---------------------
Adresse: AKN GraphQl URL
Methode: POST
Authentifizierung: Basic-Authentication
Header: X-PIM-CLIENT-ID,X-PIM-TOKEN,X-PIM-URL
Body: {"query":"query GetCategories { categories(codes: \"${header.AKN PIM Category code}\") { items { code } } }"}

Response Handling: 
- Response Beispiel: 
{
  "data": { "categories": { "items": [ { "code": "shoes_men_sneakers" } ] } }
}
- Prüfung ob die Response Kategorien enthält ("code" gibt einen Kategoriecode zurück)


4. Mapping:
----------------------------------
Befolge die Anweisungen des Mapping-Blocks.


5. Request: "Send Categories to Commerce Cloud":
-------------------------
Adresse: CommerceCloudURL
Methode: POST
Authentifizierung: Basic-Authentication
Header: keine
Body: Message Body nach dem Mapping


Modularitätsanforderungen:
1. Schreibe eine separate Funktion für jeden API-Call
2. Schreibe eine separate Funktion für das Mapping
3. Schreibe eine separate Funktion zum festlegen der Werte (Headers & Properties)
4. Schreibe eine separate Funktion für das Error Handling

Mapping-Anforderungen:
Request Mapping (Send Categories):
- Konvertiere von JSON zu XML
- "items"-Array = "Categories"
- "id" = ${property.catId}
- "version" = ${property.catVersion}
- "code" = ${header.AKN PIM Category code}
- dazugehörige "integrationKey"-Elemente haben jeweils den gleichen Wert

Output: 
<?xml version="1.0" encoding="UTF-8"?>
<Categories>
  <Category>
    <catalogVersion>
      <CatalogVersion>
        <catalog>
          <Catalog>
            <id>1.0</id>
            <integrationKey>1.0</integrationKey>
          </Catalog>
        </catalog>
        <version>Online</version>
        <integrationKey>Online</integrationKey>
      </CatalogVersion>
    </catalogVersion>
    <code>123</code>
    <integrationKey>123</integrationKey>
  </Category>
</Categories>

Output Schema:
<xs:schema attributeFormDefault="unqualified" elementFormDefault="qualified"
  xmlns:xs="http://www.w3.org/2001/XMLSchema">
  <xs:element name="Categories">
    <xs:complexType>
      <xs:sequence>
        <xs:element name="Category">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="catalogVersion">
                <xs:complexType>
                  <xs:sequence>
                    <xs:element name="CatalogVersion">
                      <xs:complexType>
                        <xs:sequence>
                          <xs:element name="catalog">
                            <xs:complexType>
                              <xs:sequence>
                                <xs:element name="Catalog">
                                  <xs:complexType>
                                    <xs:sequence>
                                      <xs:element type="xs:string" name="id"/>
                                      <xs:element type="xs:string" name="integrationKey"/>
                                    </xs:sequence>
                                  </xs:complexType>
                                </xs:element>
                              </xs:sequence>
                            </xs:complexType>
                          </xs:element>
                          <xs:element type="xs:string" name="version"/>
                          <xs:element type="xs:string" name="integrationKey"/>
                        </xs:sequence>
                      </xs:complexType>
                    </xs:element>
                  </xs:sequence>
                </xs:complexType>
              </xs:element>
              <xs:element type="xs:string" name="code"/>
              <xs:element type="xs:string" name="integrationKey"/>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
</xs:schema>