/****************************************************************************************
 *  Groovy-Skript:  EPS UK – Employer Payment Summary (21-22)
 *  Autor        :  Generated by ChatGPT
 *  Version      : 1.0
 *  Beschreibung :  1.   Mapping des eingehenden Payloads auf das GovTalk-Schema
 *                  2.   Berechnung des SHA-1-Digests (IRmark)
 *                  3.   Ablage des Original-Payloads im DataStore „EPS21-22“
 *                  4.   HTTP-Call „Set Results“ an HMRC (Basic-Auth)
 *                  5.   Umfangreiches Error-Handling inkl. Attachment
 ****************************************************************************************/
import com.sap.gateway.ip.core.customdev.util.Message
import com.sap.it.api.asdk.runtime.Factory
import com.sap.it.api.asdk.datastore.*           // DataStoreService, DataBean, DataConfig
import java.security.MessageDigest
import java.util.UUID
import groovy.xml.MarkupBuilder
import java.nio.charset.StandardCharsets

Message processData(Message message) {

    // ----------------------------------------------------------------------------------------------------------------
    // Initiales Setup
    // ----------------------------------------------------------------------------------------------------------------
    def messageLog = messageLogFactory.getMessageLog(message)
    String originalBody = message.getBody(String) ?: ''

    try {

        // 1) Request-Konstanten ermitteln
        def req = readRequestConfiguration(message)

        // 2) Original-Payload im DataStore sichern
        writeToDataStore(originalBody, req.messageId, messageLog)

        // 3) Mapping durchführen
        String mappedPayload = performMapping(originalBody, messageLog)

        // 4) SHA-1 ermitteln und IRmark einfügen
        String finalPayload  = addIRMark(mappedPayload, messageLog)

        // 5) HTTP-Request „Set Results“
        callSetResultsApi(finalPayload, req, messageLog)

        // 6) Ergebnis als Body zurückgeben
        message.setBody(finalPayload)
        return message

    } catch (Exception e) {
        handleError(originalBody, e, messageLog)   // wirft RuntimeException weiter
    }

}

/* *******************************************************************************************************************
 *  Funktion: readRequestConfiguration
 *  Aufgabe : Ermittelt User/Password/URL aus Properties/Header oder setzt „placeholder“.
 ********************************************************************************************************************/
private static Map readRequestConfiguration(Message msg) {
    def props   = msg.getProperties()
    def headers = msg.getHeaders()

    String user = props.requestUser    ?: headers.requestUser    ?: 'placeholder'
    String pass = props.requestPassword?: headers.requestPassword?: 'placeholder'
    String url  = props.requestURL     ?: headers.requestURL     ?: 'placeholder'

    // MessageProcessing-ID ermitteln (fällt auf UUID zurück)
    String msgId = (props.SAP_MessageProcessingId ?: headers.SAP_MessageProcessingId ?: UUID.randomUUID().toString())

    // Für nachgelagerte Adapter ggf. interessant
    msg.setProperty('requestUser' , user)
    msg.setProperty('requestURL'  , url)

    return [user:user, pass:pass, url:url, messageId:msgId]
}

/* *******************************************************************************************************************
 *  Funktion: performMapping
 *  Aufgabe : Führt das XML-Mapping gem. Vorgabe aus.
 ********************************************************************************************************************/
private static String performMapping(String inputXml, def messageLog) {

    def input
    try {
        input = new XmlSlurper().parseText(inputXml)
    } catch (Exception e) {
        throw new IllegalArgumentException('Eingehender Payload ist kein gültiges XML.', e)
    }

    // Validierung der benötigten Felder
    ['SenderID','Value','Product','Timestamp','PeriodEnd'].each { fld ->
        if (!input[fld]?.text()) {
            throw new IllegalArgumentException("Pflichtfeld '${fld}' fehlt im Eingabepayload.")
        }
    }

    // Erstellung des Ziel-XML
    def sw  = new StringWriter()
    def mb  = new MarkupBuilder(sw)
    mb.GovTalkMessage(xmlns:'http://www.govtalk.gov.uk/CM/envelope') {
        EnvelopeVersion('')
        Header {
            MessageDetails {
                Class('')
                Qualifier('')
            }
            SenderDetails {
                IDAuthentication {
                    SenderID(input.SenderID.text())
                    Authentication {
                        Method('')
                        Value(input.Value.text())
                    }
                }
            }
        }
        GovTalkDetails {
            ChannelRouting {
                Channel {
                    Product(input.Product.text())
                }
                Timestamp(input.Timestamp.text())
            }
        }
        Body {
            // Wegen abweichender Namespace Angabe via MarkupBuilder
            mkp.yieldUnescaped(buildRtiEnvelope(input.PeriodEnd.text()))
        }
    }
    return sw.toString()
}

/* *******************************************************************************************************************
 *  Funktion: buildRtiEnvelope
 *  Aufgabe : Liefert das IRenvelope-Fragment (als String) zurück.
 ********************************************************************************************************************/
private static String buildRtiEnvelope(String periodEnd) {
    """<IRenvelope xmlns="http://www.govtalk.gov.uk/taxation/PAYE/RTI/EmployerPaymentSummary/21-22/1">
        <IRheader>
            <Keys>
                <Key Type="TaxOfficeNumber"/>
                <Key Type="TaxOfficeReference"/>
            </Keys>
            <PeriodEnd>${periodEnd}</PeriodEnd>
            <Sender/>
        </IRheader>
        <EmployerPaymentSummary>
            <RelatedTaxYear/>
        </EmployerPaymentSummary>
    </IRenvelope>"""
}

/* *******************************************************************************************************************
 *  Funktion: addIRMark
 *  Aufgabe : Berechnet SHA-1 über Payload und fügt IRmark in das XML ein.
 ********************************************************************************************************************/
private static String addIRMark(String xmlPayload, def messageLog) {

    // SHA-1 Digest berechnen (Hex-String)
    byte[] sha1 = MessageDigest.getInstance('SHA-1')
                               .digest(xmlPayload.getBytes(StandardCharsets.UTF_8))
    String digest = sha1.collect { String.format('%02x', it) }.join()

    // IRmark direkt in IRheader einfügen (vor <Sender/>)
    def pattern = ~/(?i)<Sender\s*\/>/
    if (!pattern.matcher(xmlPayload).find()) {
        throw new IllegalStateException('Konnte <Sender/> Element nicht finden, IRmark kann nicht gesetzt werden.')
    }
    String withIrMark = xmlPayload.replaceFirst(pattern) { m -> "<IRmark>${digest}</IRmark>${m}" }

    messageLog?.addAttachmentAsString('IRmark', digest, 'text/plain')
    return withIrMark
}

/* *******************************************************************************************************************
 *  Funktion: writeToDataStore
 *  Aufgabe : Ablage des Original-Payloads.
 ********************************************************************************************************************/
private static void writeToDataStore(String payload, String entryId, def messageLog) {

    def service = new Factory(DataStoreService.class).getService()
    if (service == null) {
        throw new IllegalStateException('DataStoreService konnte nicht initialisiert werden.')
    }

    DataBean  dBean  = new DataBean()
    dBean.setDataAsArray(payload.getBytes('UTF-8'))

    DataConfig dConf = new DataConfig()
    dConf.setStoreName('EPS21-22')
    dConf.setId(entryId)
    dConf.setOverwrite(true)

    service.put(dBean, dConf)
    messageLog?.addAttachmentAsString('DataStoreInfo', "Entry ${entryId} erfolgreich geschrieben.", 'text/plain')
}

/* *******************************************************************************************************************
 *  Funktion: callSetResultsApi
 *  Aufgabe : Ausführung des HTTP-POST (keine Response Verarbeitung notwendig)
 ********************************************************************************************************************/
private static void callSetResultsApi(String payload, Map req, def messageLog) {

    if (req.url == 'placeholder') {
        messageLog?.addAttachmentAsString('HTTP-Info', 'URL = placeholder – HTTP Call wird übersprungen.', 'text/plain')
        return
    }

    def urlConn  = new URL(req.url)
    def conn     = (HttpURLConnection) urlConn.openConnection()
    conn.requestMethod = 'POST'
    conn.doOutput      = true
    conn.setRequestProperty('Content-Type', 'application/xml; charset=UTF-8')
    String auth = "${req.user}:${req.pass}".getBytes('UTF-8').encodeBase64().toString()
    conn.setRequestProperty('Authorization', "Basic ${auth}")

    conn.withOutputStream { it.write(payload.getBytes('UTF-8')) }

    int rc = conn.responseCode
    messageLog?.addAttachmentAsString('HTTP-Status', "Response-Code: ${rc}", 'text/plain')

    // Es ist kein Response-Handling gefordert – Verbindung schließen
    conn.inputStream?.close()
    conn.errorStream?.close()
    conn.disconnect()
}

/* *******************************************************************************************************************
 *  Funktion: handleError
 *  Aufgabe : Einheitliche Fehlerbehandlung inkl. Attachment des fehlerhaften Payloads.
 ********************************************************************************************************************/
private static void handleError(String body, Exception e, def messageLog) {
    messageLog?.addAttachmentAsString('ErrorPayload', body ?: '', 'text/xml')
    def errorMsg = "Fehler im EPS-Skript: ${e.message}"
    throw new RuntimeException(errorMsg, e)
}